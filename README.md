# TIL

Inspired by the likes of https://github.com/jbranchaud/til

---

###Categories
* [COM Interop / Platform Invoke](#com-interop--platform-invoke)
* [Git](#git)
* [Log4net](#log4net)
* [Visual Studio Shortcuts](#visual-studio-shortcuts)
* [Visual Studio Team Services](#visual-studio-team-services)
* [Xamarin](#xamarin)
 
---

###COM Interop / Platform Invoke
#####Creating COM classes with .NET
When creating a COM class in C# ensure that you stop .NET creating autogenerated interfaces by using the ClassInterface.None attribute
```C#
    [Guid("519BE8F6-6E28-47EC-96E5-9FF1D7FC1522")]
    [ClassInterface(ClassInterfaceType.None)]
    public class SaraClass : ISaraClass
    {
        public string GetGreeting()
        {
            return "Hello";
        }
    }
```

You'll also need to tell the interface which COM interface it should inherit from
```C#
    [Guid("846D44C9-230D-4D65-BF1E-0DD5CFD552D4")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ISaraClass
    {
        string GetGreeting();
    }
```

#####Using Platform Invoke to directly access a dll
In order to access an unmanaged class directly without registering it in COM you can add it as an isolated reference. If however this doesn't work out (for example if an alternative version with the same signature is registered in COM and referenced by the solution) then you can use Platform Invoke to directly import it.

```C#
    public class Externals
    {
        [DllImport("Sara.dll", CharSet = CharSet.Unicode, ExactSpelling = true, PreserveSig = false)]
        [return: MarshalAs(UnmanagedType.Interface)]
        public static extern object DllGetClassObject([In, MarshalAs(UnmanagedType.LPStruct)]Guid rclsid, [In, MarshalAs(UnmanagedType.LPStruct)]Guid riid);

        public const string IClassFactoryGuid = "00000001-0000-0000-C000-000000000046";
    }
    [ComImport, ComVisible(false), InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid(Externals.IClassFactoryGuid)]
    public interface IClassFactory
    {
        void CreateInstance([MarshalAs(UnmanagedType.IUnknown)] object pUnkOuter, [MarshalAs(UnmanagedType.LPStruct)] Guid riid, out IntPtr ppvObject);
        void LockServer([MarshalAs(UnmanagedType.Bool)] bool fLock);
    }
```

DllGetClassObject returns a Class Factory which can be used to create the object
```C#
        private static T GetObjectFromSaraDll<T>(Guid classGuid, Guid interfaceGuid) where T : class
        {
            var dllGetClassObject = Externals.DllGetClassObject(classGuid, new Guid(Externals.IClassFactoryGuid));
            var factory = dllGetClassObject as IClassFactory;

            IntPtr objectPtr;
            factory.CreateInstance(null, interfaceGuid, out objectPtr);

            var objectForIUnknown = Marshal.GetObjectForIUnknown(objectPtr);

            return objectForIUnknown as T;
        }
```

###Git
#####Merging Repositories and keeping history
To merge one repository into another and retain history is quite simple:
 1. Go to the branch of the repository you're keeping
 2. Add the repository that you want to bring in as a remote
 3. Pull from the repository that you're bringing in
 4. Resolve any conflicts
 5. Remove the remote
 6. Commit
 7. Done!

```Shell
cd path/to/project-b
git remote add project-a path/to/project-a
git fetch project-a
git merge project-a/master # or whichever branch you want to merge
git remote remove project-a
```

#####Undoing changes to a subset of files in a commit when Origin has been pushed
 1. Soft reset to the commit prior to the mistake commit that you are undoing
 2. Unstage the changes that you don't want to commit
 3. Commit the modified staging locally
 4. Create a local branch at this point (I called mine holdit)
 5. Hard reset the master local branch back to the mistake commit
 6. Reverse the mistake commit locally
 7. Merge back in the holdit branch 
 8. Delete the holdit branch
 9. Recommit to origin


###Log4net
To setup log4net you need a logger and a configuration file. This example shows setting up a logger in a dll (not something you'd usually do, set it up in the exe and pass around the reference if you can) which is why the additional "find the configuration file it's by the dll" code is necessary.
```C#
using log4net;
using log4net.Config;

namespace SaraExamples
{
    public class SaraLogger
    {
        private readonly ILog logger;

        public SaraLogger()
        {
            logger = LogManager.GetLogger(typeof(SaraLogger));
            var assemblyLocation=GetType().Assembly.Location;
            XmlConfigurator.Configure(new FileInfo(Path.Combine(Path.GetDirectoryName(assemblyLocation),"loggingConfig.xml")));
        }
    }
}
```
Here are the entire contents of the log4net configuration file.
```XML
<log4net>
    <appender name="RollingFile" type="log4net.Appender.RollingFileAppender">
        <file value="C:\Logs\sara.log" />
        <appendToFile value="true" />
        <maximumFileSize value="100KB" />
        <maxSizeRollBackups value="2" />

        <layout type="log4net.Layout.PatternLayout">
            <conversionPattern value="%date [%thread] %-5level %logger - %message%newline" />
        </layout>
    </appender>
    
    <root>
        <level value="DEBUG" />
        <appender-ref ref="RollingFile" />
    </root>
</log4net>
```

###Visual Studio Shortcuts
- Alt+Shift -> Block select
- Alt+Up/Alt+Down -> Move line up/down
- Ctrl+Tab -> Switch tabs
- Ctrl+D -> Duplicate line
- Ctrl+K Ctrl+D -> Format document
- Ctrl+R r -> Rename method
- Shift+F10 -> Right click

###Visual Studio Team Services
Build versioning - [Colin's AlM Corner Build & Release Tools](https://marketplace.visualstudio.com/items?itemName=colinsalmcorner.colinsalmcorner-buildtasks) - this is an extension to VSTS that allows automatic custom versioning by the build process.

###Xamarin
